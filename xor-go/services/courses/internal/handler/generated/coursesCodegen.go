// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package generated

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	uuid "github.com/google/uuid"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ActorAuthScopes = "actorAuth.Scopes"
)

// Defines values for CourseVisibility.
const (
	CourseVisibilityHidden  CourseVisibility = "Hidden"
	CourseVisibilityVisible CourseVisibility = "Visible"
)

// Defines values for LessonVisibility.
const (
	LessonVisibilityHidden  LessonVisibility = "Hidden"
	LessonVisibilityVisible LessonVisibility = "Visible"
)

// Defines values for LessonAccessAccessStatus.
const (
	Accessible   LessonAccessAccessStatus = "Accessible"
	Inaccessible LessonAccessAccessStatus = "Inaccessible"
	Pending      LessonAccessAccessStatus = "Pending"
)

// Defines values for PublicationRequestRequestStatus.
const (
	Approved  PublicationRequestRequestStatus = "Approved"
	Rejected  PublicationRequestRequestStatus = "Rejected"
	Unwatched PublicationRequestRequestStatus = "Unwatched"
)

// Defines values for SectionVisibility.
const (
	SectionVisibilityHidden  SectionVisibility = "Hidden"
	SectionVisibilityVisible SectionVisibility = "Visible"
)

// Defines values for ThemeVisibility.
const (
	ThemeVisibilityHidden  ThemeVisibility = "Hidden"
	ThemeVisibilityVisible ThemeVisibility = "Visible"
)

// Actor defines model for Actor.
type Actor struct {
	// ID Unique identifier for the actor.
	ID uuid.UUID `json:"ID"`

	// Roles Roles of the actor.
	Roles []string `json:"Roles"`
}

// Course defines model for Course.
type Course struct {
	Discipline string           `json:"Discipline"`
	FeedbackID uuid.UUID        `json:"FeedbackID,omitempty"`
	ID         uuid.UUID        `json:"ID,omitempty"`
	Landing    string           `json:"Landing"`
	Name       string           `json:"Name"`
	Sections   *[]Section       `json:"Sections,omitempty"`
	TeacherID  uuid.UUID        `json:"TeacherID,omitempty"`
	Visibility CourseVisibility `json:"Visibility"`
}

// CourseVisibility defines model for Course.Visibility.
type CourseVisibility string

// Lesson defines model for Lesson.
type Lesson struct {
	CourseID   uuid.UUID        `json:"CourseID,omitempty"`
	ID         uuid.UUID        `json:"ID,omitempty"`
	Product    *Product         `json:"Product,omitempty"`
	TeacherID  uuid.UUID        `json:"TeacherID,omitempty"`
	Transcript string           `json:"Transcript"`
	VideoURI   *string          `json:"VideoURI,omitempty"`
	Visibility LessonVisibility `json:"Visibility"`
}

// LessonVisibility defines model for Lesson.Visibility.
type LessonVisibility string

// LessonAccess defines model for LessonAccess.
type LessonAccess struct {
	// AccessStatus Access status of the lesson.
	AccessStatus *LessonAccessAccessStatus `json:"AccessStatus,omitempty"`

	// ID Unique identifier for the lesson access.
	ID uuid.UUID `json:"ID,omitempty"`

	// LessonID ID of the lesson.
	LessonID uuid.UUID `json:"LessonID,omitempty"`

	// StudentID ID of the student.
	StudentID uuid.UUID `json:"StudentID,omitempty"`

	// UpdatedAt Date and time when the request was last updated.
	UpdatedAt *time.Time `json:"UpdatedAt,omitempty"`
}

// LessonAccessAccessStatus Access status of the lesson.
type LessonAccessAccessStatus string

// OptionalActor defines model for OptionalActor.
type OptionalActor struct {
	// ID Unique identifier for the actor.
	ID uuid.UUID `json:"ID,omitempty"`

	// Roles Roles of the actor.
	Roles *[]string `json:"Roles,omitempty"`
}

// PaymentRedirect defines model for PaymentRedirect.
type PaymentRedirect struct {
	// Response Payment redirect URL.
	Response *string `json:"response,omitempty"`
}

// Product defines model for Product.
type Product struct {
	// ID Unique identifier for the product.
	ID uuid.UUID `json:"ID,omitempty"`

	// Item ID of the item associated with the product.
	Item uuid.UUID `json:"Item"`

	// Owner ID of the owner of the product.
	Owner uuid.UUID `json:"Owner"`

	// Price Price of the product.
	Price float32 `json:"Price"`
}

// PublicationRequest defines model for PublicationRequest.
type PublicationRequest struct {
	// AssigneeID ID of the assignee (teacher or moderator).
	AssigneeID uuid.UUID `json:"AssigneeID,omitempty"`

	// Comment Optional comment provided by the assignee.
	Comment *string `json:"Comment,omitempty"`

	// CourseID ID of the course associated with the request.
	CourseID uuid.UUID `json:"CourseID,omitempty"`

	// ID Unique identifier for the publication request.
	ID uuid.UUID `json:"ID,omitempty"`

	// RequestStatus Status of the publication request.
	RequestStatus *PublicationRequestRequestStatus `json:"RequestStatus,omitempty"`

	// UpdatedAt Date and time when the request was last updated.
	UpdatedAt *time.Time `json:"UpdatedAt,omitempty"`
}

// PublicationRequestRequestStatus Status of the publication request.
type PublicationRequestRequestStatus string

// Section defines model for Section.
type Section struct {
	Description string            `json:"Description"`
	FeedbackID  uuid.UUID         `json:"FeedbackID,omitempty"`
	Heading     string            `json:"Heading"`
	ID          uuid.UUID         `json:"ID,omitempty"`
	Themes      *[]Theme          `json:"Themes,omitempty"`
	Visibility  SectionVisibility `json:"Visibility"`
}

// SectionVisibility defines model for Section.Visibility.
type SectionVisibility string

// Student defines model for Student.
type Student struct {
	// AccountID ID of the student's account.
	AccountID uuid.UUID `json:"AccountID,omitempty"`
}

// Teacher defines model for Teacher.
type Teacher struct {
	// AccountID ID of the teacher's account.
	AccountID uuid.UUID `json:"AccountID,omitempty"`
}

// Theme defines model for Theme.
type Theme struct {
	FeedbackID uuid.UUID `json:"FeedbackID,omitempty"`
	Heading    string    `json:"Heading"`
	ID         uuid.UUID `json:"ID,omitempty"`

	// LessonIDs Lessons in theme.
	LessonIDs  *[]uuid.UUID    `json:"LessonIDs,omitempty"`
	Visibility ThemeVisibility `json:"Visibility"`
}

// ThemeVisibility defines model for Theme.Visibility.
type ThemeVisibility string

// GetCoursesEditParams defines parameters for GetCoursesEdit.
type GetCoursesEditParams struct {
	Actor Actor `json:"actor"`
}

// PostCoursesEditParams defines parameters for PostCoursesEdit.
type PostCoursesEditParams struct {
	Actor Actor `json:"actor"`
}

// DeleteCoursesEditCourseIDParams defines parameters for DeleteCoursesEditCourseID.
type DeleteCoursesEditCourseIDParams struct {
	Actor Actor `json:"actor"`
}

// GetCoursesEditCourseIDParams defines parameters for GetCoursesEditCourseID.
type GetCoursesEditCourseIDParams struct {
	Actor Actor `json:"actor"`
}

// PutCoursesEditCourseIDParams defines parameters for PutCoursesEditCourseID.
type PutCoursesEditCourseIDParams struct {
	Actor Actor `json:"actor"`
}

// GetCoursesCourseIDParams defines parameters for GetCoursesCourseID.
type GetCoursesCourseIDParams struct {
	Actor *OptionalActor `json:"actor,omitempty"`
}

// PostCoursesCourseIDBuyParams defines parameters for PostCoursesCourseIDBuy.
type PostCoursesCourseIDBuyParams struct {
	Actor Actor `json:"actor"`
}

// PostLessonsEditParams defines parameters for PostLessonsEdit.
type PostLessonsEditParams struct {
	Actor Actor `json:"actor"`
}

// DeleteLessonsEditLessonIDParams defines parameters for DeleteLessonsEditLessonID.
type DeleteLessonsEditLessonIDParams struct {
	Actor Actor `json:"actor"`
}

// GetLessonsEditLessonIDParams defines parameters for GetLessonsEditLessonID.
type GetLessonsEditLessonIDParams struct {
	Actor Actor `json:"actor"`
}

// PutLessonsEditLessonIDParams defines parameters for PutLessonsEditLessonID.
type PutLessonsEditLessonIDParams struct {
	Actor Actor `json:"actor"`
}

// GetLessonsLessonIDParams defines parameters for GetLessonsLessonID.
type GetLessonsLessonIDParams struct {
	Actor *OptionalActor `json:"actor,omitempty"`
}

// PostLessonsLessonIDBuyParams defines parameters for PostLessonsLessonIDBuy.
type PostLessonsLessonIDBuyParams struct {
	Actor Actor `json:"actor"`
}

// PostPublicationRequestsParams defines parameters for PostPublicationRequests.
type PostPublicationRequestsParams struct {
	Actor Actor `json:"actor"`
}

// PutPublicationRequestsRequestIDParams defines parameters for PutPublicationRequestsRequestID.
type PutPublicationRequestsRequestIDParams struct {
	Actor Actor `json:"actor"`
}

// PostStudentsRegisterParams defines parameters for PostStudentsRegister.
type PostStudentsRegisterParams struct {
	Actor *OptionalActor `json:"actor,omitempty"`
}

// PostTeachersRegisterParams defines parameters for PostTeachersRegister.
type PostTeachersRegisterParams struct {
	Actor *OptionalActor `json:"actor,omitempty"`
}

// PostUserAccessConfirmJSONBody defines parameters for PostUserAccessConfirm.
type PostUserAccessConfirmJSONBody struct {
	// BuyerID ID of the buyer.
	BuyerID  *openapi_types.UUID `json:"buyerID,omitempty"`
	Products *[]Product          `json:"products,omitempty"`
}

// PutUserAccessLessonsParams defines parameters for PutUserAccessLessons.
type PutUserAccessLessonsParams struct {
	Actor Actor `json:"actor"`
}

// GetUserAccessLessonsLessonIDParams defines parameters for GetUserAccessLessonsLessonID.
type GetUserAccessLessonsLessonIDParams struct {
	Actor Actor `json:"actor"`
}

// PostCoursesEditJSONRequestBody defines body for PostCoursesEdit for application/json ContentType.
type PostCoursesEditJSONRequestBody = Course

// PutCoursesEditCourseIDJSONRequestBody defines body for PutCoursesEditCourseID for application/json ContentType.
type PutCoursesEditCourseIDJSONRequestBody = Course

// PostLessonsEditJSONRequestBody defines body for PostLessonsEdit for application/json ContentType.
type PostLessonsEditJSONRequestBody = Lesson

// PutLessonsEditLessonIDJSONRequestBody defines body for PutLessonsEditLessonID for application/json ContentType.
type PutLessonsEditLessonIDJSONRequestBody = Lesson

// PostPublicationRequestsJSONRequestBody defines body for PostPublicationRequests for application/json ContentType.
type PostPublicationRequestsJSONRequestBody = PublicationRequest

// PostStudentsRegisterJSONRequestBody defines body for PostStudentsRegister for application/json ContentType.
type PostStudentsRegisterJSONRequestBody = Student

// PostTeachersRegisterJSONRequestBody defines body for PostTeachersRegister for application/json ContentType.
type PostTeachersRegisterJSONRequestBody = Teacher

// PostUserAccessConfirmJSONRequestBody defines body for PostUserAccessConfirm for application/json ContentType.
type PostUserAccessConfirmJSONRequestBody PostUserAccessConfirmJSONBody

// PutUserAccessLessonsJSONRequestBody defines body for PutUserAccessLessons for application/json ContentType.
type PutUserAccessLessonsJSONRequestBody = LessonAccess

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Courses
	// (GET /courses/edit)
	GetCoursesEdit(c *gin.Context, params GetCoursesEditParams)
	// Create Course
	// (POST /courses/edit)
	PostCoursesEdit(c *gin.Context, params PostCoursesEditParams)
	// Delete Course
	// (DELETE /courses/edit/{courseID})
	DeleteCoursesEditCourseID(c *gin.Context, courseID openapi_types.UUID, params DeleteCoursesEditCourseIDParams)
	// Get Course by ID
	// (GET /courses/edit/{courseID})
	GetCoursesEditCourseID(c *gin.Context, courseID openapi_types.UUID, params GetCoursesEditCourseIDParams)
	// Update Course
	// (PUT /courses/edit/{courseID})
	PutCoursesEditCourseID(c *gin.Context, courseID openapi_types.UUID, params PutCoursesEditCourseIDParams)
	// Read published Course
	// (GET /courses/{courseID})
	GetCoursesCourseID(c *gin.Context, courseID openapi_types.UUID, params GetCoursesCourseIDParams)
	// Buy Course
	// (POST /courses/{courseID}/buy)
	PostCoursesCourseIDBuy(c *gin.Context, courseID openapi_types.UUID, params PostCoursesCourseIDBuyParams)
	// Create Lesson
	// (POST /lessons/edit/)
	PostLessonsEdit(c *gin.Context, params PostLessonsEditParams)
	// Delete Lesson
	// (DELETE /lessons/edit/{lessonID})
	DeleteLessonsEditLessonID(c *gin.Context, lessonID openapi_types.UUID, params DeleteLessonsEditLessonIDParams)
	// Retrieve Lesson
	// (GET /lessons/edit/{lessonID})
	GetLessonsEditLessonID(c *gin.Context, lessonID openapi_types.UUID, params GetLessonsEditLessonIDParams)
	// Update Lesson
	// (PUT /lessons/edit/{lessonID})
	PutLessonsEditLessonID(c *gin.Context, lessonID openapi_types.UUID, params PutLessonsEditLessonIDParams)
	// Retrieve published Lesson
	// (GET /lessons/{lessonID})
	GetLessonsLessonID(c *gin.Context, lessonID openapi_types.UUID, params GetLessonsLessonIDParams)
	// Buy Lesson
	// (POST /lessons/{lessonID}/buy)
	PostLessonsLessonIDBuy(c *gin.Context, lessonID openapi_types.UUID, params PostLessonsLessonIDBuyParams)
	// Request Course Publication
	// (POST /publication-requests)
	PostPublicationRequests(c *gin.Context, params PostPublicationRequestsParams)
	// Update Publication Request
	// (PUT /publication-requests/{requestID})
	PutPublicationRequestsRequestID(c *gin.Context, requestID openapi_types.UUID, params PutPublicationRequestsRequestIDParams)
	// Register Student Profile
	// (POST /students/register)
	PostStudentsRegister(c *gin.Context, params PostStudentsRegisterParams)
	// Register Teacher Profile
	// (POST /teachers/register)
	PostTeachersRegister(c *gin.Context, params PostTeachersRegisterParams)
	// Confirm user access to products
	// (POST /user/access/confirm)
	PostUserAccessConfirm(c *gin.Context)
	// Change student's access to lesson
	// (PUT /user/access/lessons)
	PutUserAccessLessons(c *gin.Context, params PutUserAccessLessonsParams)
	// Get actor's lesson access
	// (GET /user/access/lessons/{lessonID})
	GetUserAccessLessonsLessonID(c *gin.Context, lessonID openapi_types.UUID, params GetUserAccessLessonsLessonIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetCoursesEdit operation middleware
func (siw *ServerInterfaceWrapper) GetCoursesEdit(c *gin.Context) {

	var err error

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCoursesEditParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCoursesEdit(c, params)
}

// PostCoursesEdit operation middleware
func (siw *ServerInterfaceWrapper) PostCoursesEdit(c *gin.Context) {

	var err error

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCoursesEditParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostCoursesEdit(c, params)
}

// DeleteCoursesEditCourseID operation middleware
func (siw *ServerInterfaceWrapper) DeleteCoursesEditCourseID(c *gin.Context) {

	var err error

	// ------------- Path parameter "courseID" -------------
	var courseID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "courseID", c.Param("courseID"), &courseID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter courseID: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCoursesEditCourseIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteCoursesEditCourseID(c, courseID, params)
}

// GetCoursesEditCourseID operation middleware
func (siw *ServerInterfaceWrapper) GetCoursesEditCourseID(c *gin.Context) {

	var err error

	// ------------- Path parameter "courseID" -------------
	var courseID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "courseID", c.Param("courseID"), &courseID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter courseID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCoursesEditCourseIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCoursesEditCourseID(c, courseID, params)
}

// PutCoursesEditCourseID operation middleware
func (siw *ServerInterfaceWrapper) PutCoursesEditCourseID(c *gin.Context) {

	var err error

	// ------------- Path parameter "courseID" -------------
	var courseID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "courseID", c.Param("courseID"), &courseID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter courseID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutCoursesEditCourseIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutCoursesEditCourseID(c, courseID, params)
}

// GetCoursesCourseID operation middleware
func (siw *ServerInterfaceWrapper) GetCoursesCourseID(c *gin.Context) {

	var err error

	// ------------- Path parameter "courseID" -------------
	var courseID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "courseID", c.Param("courseID"), &courseID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter courseID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCoursesCourseIDParams

	headers := c.Request.Header

	// ------------- Optional header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor OptionalActor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = &Actor

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCoursesCourseID(c, courseID, params)
}

// PostCoursesCourseIDBuy operation middleware
func (siw *ServerInterfaceWrapper) PostCoursesCourseIDBuy(c *gin.Context) {

	var err error

	// ------------- Path parameter "courseID" -------------
	var courseID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "courseID", c.Param("courseID"), &courseID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter courseID: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCoursesCourseIDBuyParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostCoursesCourseIDBuy(c, courseID, params)
}

// PostLessonsEdit operation middleware
func (siw *ServerInterfaceWrapper) PostLessonsEdit(c *gin.Context) {

	var err error

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostLessonsEditParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLessonsEdit(c, params)
}

// DeleteLessonsEditLessonID operation middleware
func (siw *ServerInterfaceWrapper) DeleteLessonsEditLessonID(c *gin.Context) {

	var err error

	// ------------- Path parameter "lessonID" -------------
	var lessonID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "lessonID", c.Param("lessonID"), &lessonID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lessonID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteLessonsEditLessonIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteLessonsEditLessonID(c, lessonID, params)
}

// GetLessonsEditLessonID operation middleware
func (siw *ServerInterfaceWrapper) GetLessonsEditLessonID(c *gin.Context) {

	var err error

	// ------------- Path parameter "lessonID" -------------
	var lessonID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "lessonID", c.Param("lessonID"), &lessonID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lessonID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLessonsEditLessonIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetLessonsEditLessonID(c, lessonID, params)
}

// PutLessonsEditLessonID operation middleware
func (siw *ServerInterfaceWrapper) PutLessonsEditLessonID(c *gin.Context) {

	var err error

	// ------------- Path parameter "lessonID" -------------
	var lessonID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "lessonID", c.Param("lessonID"), &lessonID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lessonID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutLessonsEditLessonIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutLessonsEditLessonID(c, lessonID, params)
}

// GetLessonsLessonID operation middleware
func (siw *ServerInterfaceWrapper) GetLessonsLessonID(c *gin.Context) {

	var err error

	// ------------- Path parameter "lessonID" -------------
	var lessonID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "lessonID", c.Param("lessonID"), &lessonID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lessonID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ActorAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLessonsLessonIDParams

	headers := c.Request.Header

	// ------------- Optional header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor OptionalActor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = &Actor

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetLessonsLessonID(c, lessonID, params)
}

// PostLessonsLessonIDBuy operation middleware
func (siw *ServerInterfaceWrapper) PostLessonsLessonIDBuy(c *gin.Context) {

	var err error

	// ------------- Path parameter "lessonID" -------------
	var lessonID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "lessonID", c.Param("lessonID"), &lessonID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lessonID: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostLessonsLessonIDBuyParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLessonsLessonIDBuy(c, lessonID, params)
}

// PostPublicationRequests operation middleware
func (siw *ServerInterfaceWrapper) PostPublicationRequests(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostPublicationRequestsParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostPublicationRequests(c, params)
}

// PutPublicationRequestsRequestID operation middleware
func (siw *ServerInterfaceWrapper) PutPublicationRequestsRequestID(c *gin.Context) {

	var err error

	// ------------- Path parameter "requestID" -------------
	var requestID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "requestID", c.Param("requestID"), &requestID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requestID: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutPublicationRequestsRequestIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutPublicationRequestsRequestID(c, requestID, params)
}

// PostStudentsRegister operation middleware
func (siw *ServerInterfaceWrapper) PostStudentsRegister(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostStudentsRegisterParams

	headers := c.Request.Header

	// ------------- Optional header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor OptionalActor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = &Actor

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostStudentsRegister(c, params)
}

// PostTeachersRegister operation middleware
func (siw *ServerInterfaceWrapper) PostTeachersRegister(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostTeachersRegisterParams

	headers := c.Request.Header

	// ------------- Optional header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor OptionalActor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = &Actor

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTeachersRegister(c, params)
}

// PostUserAccessConfirm operation middleware
func (siw *ServerInterfaceWrapper) PostUserAccessConfirm(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostUserAccessConfirm(c)
}

// PutUserAccessLessons operation middleware
func (siw *ServerInterfaceWrapper) PutUserAccessLessons(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PutUserAccessLessonsParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutUserAccessLessons(c, params)
}

// GetUserAccessLessonsLessonID operation middleware
func (siw *ServerInterfaceWrapper) GetUserAccessLessonsLessonID(c *gin.Context) {

	var err error

	// ------------- Path parameter "lessonID" -------------
	var lessonID openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "lessonID", c.Param("lessonID"), &lessonID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lessonID: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserAccessLessonsLessonIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "actor" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("actor")]; found {
		var Actor Actor
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for actor, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "actor", runtime.ParamLocationHeader, valueList[0], &Actor)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter actor: %w", err), http.StatusBadRequest)
			return
		}

		params.Actor = Actor

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter actor is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserAccessLessonsLessonID(c, lessonID, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/courses/edit", wrapper.GetCoursesEdit)
	router.POST(options.BaseURL+"/courses/edit", wrapper.PostCoursesEdit)
	router.DELETE(options.BaseURL+"/courses/edit/:courseID", wrapper.DeleteCoursesEditCourseID)
	router.GET(options.BaseURL+"/courses/edit/:courseID", wrapper.GetCoursesEditCourseID)
	router.PUT(options.BaseURL+"/courses/edit/:courseID", wrapper.PutCoursesEditCourseID)
	router.GET(options.BaseURL+"/courses/:courseID", wrapper.GetCoursesCourseID)
	router.POST(options.BaseURL+"/courses/:courseID/buy", wrapper.PostCoursesCourseIDBuy)
	router.POST(options.BaseURL+"/lessons/edit/", wrapper.PostLessonsEdit)
	router.DELETE(options.BaseURL+"/lessons/edit/:lessonID", wrapper.DeleteLessonsEditLessonID)
	router.GET(options.BaseURL+"/lessons/edit/:lessonID", wrapper.GetLessonsEditLessonID)
	router.PUT(options.BaseURL+"/lessons/edit/:lessonID", wrapper.PutLessonsEditLessonID)
	router.GET(options.BaseURL+"/lessons/:lessonID", wrapper.GetLessonsLessonID)
	router.POST(options.BaseURL+"/lessons/:lessonID/buy", wrapper.PostLessonsLessonIDBuy)
	router.POST(options.BaseURL+"/publication-requests", wrapper.PostPublicationRequests)
	router.PUT(options.BaseURL+"/publication-requests/:requestID", wrapper.PutPublicationRequestsRequestID)
	router.POST(options.BaseURL+"/students/register", wrapper.PostStudentsRegister)
	router.POST(options.BaseURL+"/teachers/register", wrapper.PostTeachersRegister)
	router.POST(options.BaseURL+"/user/access/confirm", wrapper.PostUserAccessConfirm)
	router.PUT(options.BaseURL+"/user/access/lessons", wrapper.PutUserAccessLessons)
	router.GET(options.BaseURL+"/user/access/lessons/:lessonID", wrapper.GetUserAccessLessonsLessonID)
}
