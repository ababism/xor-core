// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package generated

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for TripStatus.
const (
	CANCELED     TripStatus = "CANCELED"
	DRIVERFOUND  TripStatus = "DRIVER_FOUND"
	DRIVERSEARCH TripStatus = "DRIVER_SEARCH"
	ENDED        TripStatus = "ENDED"
	ONPOSITION   TripStatus = "ON_POSITION"
	STARTED      TripStatus = "STARTED"
)

// LatLngLiteral An object describing a specific location with Latitude and Longitude in decimal degrees.
type LatLngLiteral struct {
	// Lat Latitude in decimal degrees
	Lat float32 `json:"lat"`

	// Lng Longitude in decimal degrees
	Lng float32 `json:"lng"`
}

// Money defines model for Money.
type Money struct {
	// Amount Amount expressed as a decimal number of major currency units
	Amount float64 `json:"amount"`

	// Currency 3 letter currency code as defined by ISO-4217
	Currency string `json:"currency"`
}

// Trip defines model for Trip.
type Trip struct {
	DriverId *string `json:"driver_id,omitempty"`

	// From An object describing a specific location with Latitude and Longitude in decimal degrees.
	From   *LatLngLiteral      `json:"from,omitempty"`
	Id     *openapi_types.UUID `json:"id,omitempty"`
	Price  *Money              `json:"price,omitempty"`
	Status *TripStatus         `json:"status,omitempty"`

	// To An object describing a specific location with Latitude and Longitude in decimal degrees.
	To *LatLngLiteral `json:"to,omitempty"`
}

// TripStatus defines model for Trip.Status.
type TripStatus string

// GetTripsParams defines parameters for GetTrips.
type GetTripsParams struct {
	UserId openapi_types.UUID `json:"user_id"`
}

// GetTripByIDParams defines parameters for GetTripByID.
type GetTripByIDParams struct {
	UserId openapi_types.UUID `json:"user_id"`
}

// AcceptTripParams defines parameters for AcceptTrip.
type AcceptTripParams struct {
	UserId openapi_types.UUID `json:"user_id"`
}

// CancelTripParams defines parameters for CancelTrip.
type CancelTripParams struct {
	// Reason Reason for trip cancellation
	Reason *string            `form:"reason,omitempty" json:"reason,omitempty"`
	UserId openapi_types.UUID `json:"user_id"`
}

// EndTripParams defines parameters for EndTrip.
type EndTripParams struct {
	UserId openapi_types.UUID `json:"user_id"`
}

// StartTripParams defines parameters for StartTrip.
type StartTripParams struct {
	UserId openapi_types.UUID `json:"user_id"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List trips
	// (GET /trips)
	GetTrips(c *gin.Context, params GetTripsParams)
	// Get trip by ID
	// (GET /trips/{trip_id})
	GetTripByID(c *gin.Context, tripId openapi_types.UUID, params GetTripByIDParams)
	// Accept trip
	// (POST /trips/{trip_id}/accept)
	AcceptTrip(c *gin.Context, tripId openapi_types.UUID, params AcceptTripParams)
	// Cancel trip
	// (POST /trips/{trip_id}/cancel)
	CancelTrip(c *gin.Context, tripId openapi_types.UUID, params CancelTripParams)
	// End trip
	// (POST /trips/{trip_id}/end)
	EndTrip(c *gin.Context, tripId openapi_types.UUID, params EndTripParams)
	// Start trip
	// (POST /trips/{trip_id}/start)
	StartTrip(c *gin.Context, tripId openapi_types.UUID, params StartTripParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetTrips operation middleware
func (siw *ServerInterfaceWrapper) GetTrips(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTripsParams

	headers := c.Request.Header

	// ------------- Required header parameter "user_id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("user_id")]; found {
		var UserId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for user_id, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationHeader, valueList[0], &UserId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
			return
		}

		params.UserId = UserId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTrips(c, params)
}

// GetTripByID operation middleware
func (siw *ServerInterfaceWrapper) GetTripByID(c *gin.Context) {

	var err error

	// ------------- Path parameter "trip_id" -------------
	var tripId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "trip_id", c.Param("trip_id"), &tripId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trip_id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTripByIDParams

	headers := c.Request.Header

	// ------------- Required header parameter "user_id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("user_id")]; found {
		var UserId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for user_id, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationHeader, valueList[0], &UserId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
			return
		}

		params.UserId = UserId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTripByID(c, tripId, params)
}

// AcceptTrip operation middleware
func (siw *ServerInterfaceWrapper) AcceptTrip(c *gin.Context) {

	var err error

	// ------------- Path parameter "trip_id" -------------
	var tripId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "trip_id", c.Param("trip_id"), &tripId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trip_id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AcceptTripParams

	headers := c.Request.Header

	// ------------- Required header parameter "user_id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("user_id")]; found {
		var UserId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for user_id, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationHeader, valueList[0], &UserId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
			return
		}

		params.UserId = UserId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AcceptTrip(c, tripId, params)
}

// CancelTrip operation middleware
func (siw *ServerInterfaceWrapper) CancelTrip(c *gin.Context) {

	var err error

	// ------------- Path parameter "trip_id" -------------
	var tripId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "trip_id", c.Param("trip_id"), &tripId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trip_id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CancelTripParams

	// ------------- Optional query parameter "reason" -------------

	err = runtime.BindQueryParameter("form", true, false, "reason", c.Request.URL.Query(), &params.Reason)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter reason: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "user_id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("user_id")]; found {
		var UserId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for user_id, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationHeader, valueList[0], &UserId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
			return
		}

		params.UserId = UserId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CancelTrip(c, tripId, params)
}

// EndTrip operation middleware
func (siw *ServerInterfaceWrapper) EndTrip(c *gin.Context) {

	var err error

	// ------------- Path parameter "trip_id" -------------
	var tripId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "trip_id", c.Param("trip_id"), &tripId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trip_id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params EndTripParams

	headers := c.Request.Header

	// ------------- Required header parameter "user_id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("user_id")]; found {
		var UserId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for user_id, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationHeader, valueList[0], &UserId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
			return
		}

		params.UserId = UserId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.EndTrip(c, tripId, params)
}

// StartTrip operation middleware
func (siw *ServerInterfaceWrapper) StartTrip(c *gin.Context) {

	var err error

	// ------------- Path parameter "trip_id" -------------
	var tripId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "trip_id", c.Param("trip_id"), &tripId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trip_id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params StartTripParams

	headers := c.Request.Header

	// ------------- Required header parameter "user_id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("user_id")]; found {
		var UserId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for user_id, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationHeader, valueList[0], &UserId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
			return
		}

		params.UserId = UserId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StartTrip(c, tripId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/trips", wrapper.GetTrips)
	router.GET(options.BaseURL+"/trips/:trip_id", wrapper.GetTripByID)
	router.POST(options.BaseURL+"/trips/:trip_id/accept", wrapper.AcceptTrip)
	router.POST(options.BaseURL+"/trips/:trip_id/cancel", wrapper.CancelTrip)
	router.POST(options.BaseURL+"/trips/:trip_id/end", wrapper.EndTrip)
	router.POST(options.BaseURL+"/trips/:trip_id/start", wrapper.StartTrip)
}
